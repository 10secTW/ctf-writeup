# SECCON CTF Quals - 2019

## Rev / 225 - follow-me

> I have an execution trace of calc, but I forgot what I inputted. Can you submit the input (formula) which follows my execution trace to my server?
> 
> Challenge server
> 
>     Server compares branch instructions' behavior of your input's and original execution traces, and gives you flag if these are the same.
>     
>     NOTE: You MUST NOT attack challenge server (including too frequent access).
>     
>     Location: http://follow-me.chal.seccon.jp/
>     
>     Sample curl command to submit formula: curl -q -H 'Content-Type:application/json' -d "{\"input\": \"your formula comes here\"}" http://follow-me.chal.seccon.jp/submit/quals/0
> 
> Attached files
> 
> * Executed binary (excluding dynamic libraries): [calc](calc)
> * Execution trace generated by tracer: [calc.trace](./calc.trace)
> * Source code of tracer developed on the top of Pin: [branchtrace.cpp](./branchtrace.cpp)

### Solution

By [@jaidTw](https://github.com/jaidTw)
Credits to [@raagi](https://github.com/nashi5566)

題目共給了三個檔案：
* 執行檔
* 利用Pin寫的tracer原始碼
* tracer的輸出

必須構造輸入讓程式產生與題目相同的trace才能拿到flag。
trace的格式如下：
```json
[
{"event": "image_load", "image_name": "/home/tomori/follow-me/build/sample/calc", "image_id": 1, "base_addr": "0x55f6b4d44000", "image_size": "0x1377"},
{"event": "image_load", "image_name": "/lib64/ld-linux-x86-64.so.2", "image_id": 2, "base_addr": "0x7f13ae220000", "image_size": "0x26c23"},
{"event": "image_load", "image_name": "[vdso]", "image_id": 3, "base_addr": "0x7ffc2b775000", "image_size": "0x100a"},
{"event": "image_load", "image_name": "/lib/x86_64-linux-gnu/libc.so.6", "image_id": 4, "base_addr": "0x7f1399a39000", "image_size": "0x3f0adf"},
{"event": "branch", "inst_addr": "0x55f6b4d445de", "next_inst_addr": "0", "branch_taken": true},
{"event": "branch", "inst_addr": "0x55f6b4d44f44", "next_inst_addr": "0", "branch_taken": false},
{"event": "branch", "inst_addr": "0x55f6b4d44765", "next_inst_addr": "0", "branch_taken": true},
...
{"event": "exit", "exit_code": 0}
]
```
裡面紀錄了所有分支的紀錄，因此輸入必須讓程式產生一樣的控制流程。

首先對程式進行逆向，可以發現是一個簡易的計算機，輸入是postfix expression，功能有`+`, `-`, `*`, `m`(min), `M`(max), `C`(combination)

接著將trace進行整理，根據`inst_addr`的最低12bits(ASLR不影響)，可以對應回原本執行檔中的指令，紀錄分支類型及判斷條件是否成立。

這裡使用這份[script](./trans.py)來將結果轉換為如下方便閱讀的表式：
```
# main if ( argc <= 1 ) False
# malloc@plt True
# calloc@plt True
# Unconditional

# formula_parse while( *f ) True
# formula_parse if ( *f == ',' ) False
# formula_parse if ( chr <= '/' ) False
# formula_parse if ( chr > '9' ) False
# Unconditional

# formula_parse while( *f ) True
# formula_parse if ( *f == ',' ) False
# formula_parse if ( chr <= '/' ) False
# formula_parse if ( chr > '9' ) False
# Unconditional

# formula_parse while( *f ) True
# formula_parse if ( *f == ',' ) False
# formula_parse if ( chr <= '/' ) False
# formula_parse if ( chr > '9' ) False
# Unconditional

# formula_parse while( *f ) True
# formula_parse if ( *f == ',' ) True
# formula_parse ( type == 1 ) True
# push if ( s->len > 999u ) True
# Unconditional
```

以`formula_parse`的`while`來切分trace，則每個區塊代表一次loop，其中可以發現有很多區塊相同。每種區塊代表一種字元，例如上述的片段中分別是數字、數字、數字、逗號。得出每種區塊代表的字元後，就能將每個區塊用字元替換掉，得到輸入字串格式應為

```
DDD,DDD,DDD,DDD,DDD,DDDD,DDD,mm-mM-DDD,DDD,DDD,mm-DDD,DDD,DDD,DDD,DDD,-+(4)-M+(8)DDD,DDD,DDD,mm*(1:6)
D: digit
+(n) : +, loop n次
*(n:m) *, 外層第n次中的add loop m次
```

我們必須構造數字使其滿足`add`和`mul`中迴圈的次數限制
* add的loop等於第二個參數的個位數
* mul的外層loop次數等於第二個參數，內部add的第二個參數是mul的第一個參數，內部add的迴圈次數因此是第一個參數的個位數

這些條件並不難滿足，這裡是我們的解(加上括號和縮排方便閱讀)：
```
[
    [
        [
            [
                008,[
                    000,[
                        000,[
                            000,[
                                000,[
                                    0000,000,m
                                ]m
                            ]-
                        ]m
                    ]M
                ]-
            ]
            [
                000,[
                    000,000,m
                ]m
            ]
        ]-
        [
            000,[
                011,[
                    000,[
                        004,001,-
                    ]+(4)
                ]-
            ]M
        ]+(8)
    ]
    [
        001,[
            001,001,m
        ]m
    ]*(1:6)
]
```

最後去掉括號：
```
008,000,000,000,000,0000,000,mm-mM-000,000,000,mm-000,011,000,004,001,-+-M+001,001,001,mm*
```
```
$ curl -q -H 'Content-Type:application/json' -d "{\"input\": \"008,000,000,000,000,0000,000,mm-mM-000,000,000,mm-000,011,000,004,001,-+-M+001,001,001,mm*\"}" http://follow-me.chal.seccon.jp/submit/quals/0
{"error":false,"flag":"SECCON{Is it easy for you to recovery input from execution trace? Keep hacking:)}","message":"Thanks! I'll give you a flag as a thank you."}
```
