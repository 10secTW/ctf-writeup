# BalsnCTF - 2020

## Rev / 310 - babyrev

### Solution

By [@jaidTw](https://github.com/jaidTw)

There are several JVM class files inside the zip. We decompiled them and found they were generated by Scala. Next, we studied a little bit Scala and simplified the code into below

```scala
object babyrev {
    def anon(a:Stream[Int], What:Seq[Seq[Int]]): Stream[Int] = {
        return a.sum #:: anon(a.flatMap(What), What)
    }

    def Main(args:Array[String]): Uint = {
        var What = Seq{Seq{0, 1, 2, 3}, Seq{0}, Seq{0}, Seq{0}}
        this.broken = anon(Stream({0}), What);
    }

    def Run() = {
        var a = ...
        var b = BigInt(broken.apply(60107) % Math.pow(2, 62)).toByteArray()
        var flag = ObjectRef.create("")
        0.to(a.length).forEach(i => {
            flag[i] = (char)(byte)(a[i] ^ b[i % b.length])
        })
            
        println("The flag is BALSN{" + flag + "}")
    }
}
```

In `Main`, there are a byte array `a` with fixed content and another byte array `b`, whose value came from `broken.apply(60107) % pow(2, 62)`. Later, bitwise-xor is performed on `a` and `b` to produce the `flag`. 

In `broken`, it seems weird to pass a `Seq` as the parameter to `flatMap`. But anyway, just run and test it. I did it on [Scastie](https://scastie.scala-lang.org/).

```scala
def anon(a:Stream[Int], What:Seq[Seq[Int]]): Stream[Int] = {
    return a.sum #:: anon(a.flatMap(What), What)
}

b.apply(1)
b.apply(2)
b.apply(3)
b.apply(4)
b.apply(5)
b.apply(6)
b.apply(7)
b.apply(8)
b.apply(9)
...
```

The returned values of each `b.apply()` should be
```
6
6
24
42
114
240
582
1302
3048
6954
...
```

Then, we can somehow find the pattern by repeatedly dividing each term by 3 and calculate their difference to obatin a new sequence.

|Term|1|2|3|4|5|6|7|8|9|10|...|
|-|-|-|-|-|-|-|-|-|-|-|-|
||6|6|24|42|114|240|582|1302|3048|6954||
|$\div6$|1|1|4|7|19|40|97|217|508|1159|
|diff|||3|3|12|21|57|120|291|651|
|$\div3$|||1|1|4|7|19|40|97|217
|diff|||||3|3|12|21|57|120|
|$\div3$|||||1|1|4|7|19|40

By obeservation, there is a sequence `S = <a_n> = {1, 1, 4, 7, 19, 40, ...}` and we are able to write down its recursive formula
* `a[n] = a[n-1] + 3 * a[n-2]`
* `a[1] = 1`
* `a[2] = 1`

as well as our target function `f(x) = 6 * a[x]`.

Finally, we can use the following Python script to compute $f(60107)$ and decrypt the flag.

```python
S = [1]*70000

def f(x): return 6 * S[x]

for i in range(3, 60110):
    S[i] = S[i-1] + 3*S[i-2]

a = [71, 20, -82, 84, -45, -4, 25, -122, 77, 63, -107, 13, -111, -43, 43, -42, 96, 38, -88, 20, -67, -40, 79, -108, 77, 8, -75, 80, -45, -69, 25, -116, 117, 106, -36, 69, -67, -35, 79, -114, 113, 36, -112, 87, -67, -2, 19, -67, 80, 42, -111, 23, -116, -55, 40, -92, 77, 121, -51, 86, -46, -85, 93]
b = (f(60107) % 2**62).to_bytes(length=8, byteorder='big')

for i in range(len(a)):
    print(chr((a[i] ^ b[i % len(b)]) & 0xFF), end="")
```

```
BALSN{U_S01ved_this_W4rmUp_R3v_CH411eng!!!_W3lcom3_to_BalsnCTF_2020!!}
```
